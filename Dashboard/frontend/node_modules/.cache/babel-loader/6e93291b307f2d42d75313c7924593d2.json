{"ast":null,"code":"// Licensed to Elasticsearch B.V under one or more agreements.\n// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.\n// See the LICENSE file in the project root for more information\n'use strict';\n\nconst debug = require('debug')('elasticsearch');\n\nconst os = require('os');\n\nconst once = require('once');\n\nconst _require = require('zlib'),\n      createGzip = _require.createGzip;\n\nconst intoStream = require('into-stream');\n\nconst ms = require('ms');\n\nconst _require2 = require('./errors'),\n      ConnectionError = _require2.ConnectionError,\n      TimeoutError = _require2.TimeoutError,\n      NoLivingConnectionsError = _require2.NoLivingConnectionsError,\n      ResponseError = _require2.ResponseError,\n      ConfigurationError = _require2.ConfigurationError;\n\nconst noop = () => {};\n\nconst clientVersion = require('../package.json').version;\n\nconst userAgent = \"elasticsearch-js/\".concat(clientVersion, \" (\").concat(os.platform(), \" \").concat(os.release(), \"-\").concat(os.arch(), \"; Node.js \").concat(process.version, \")\");\n\nclass Transport {\n  constructor(opts = {}) {\n    if (typeof opts.compression === 'string' && opts.compression !== 'gzip') {\n      throw new ConfigurationError(\"Invalid compression: '\".concat(opts.compression, \"'\"));\n    }\n\n    this.emit = opts.emit;\n    this.connectionPool = opts.connectionPool;\n    this.serializer = opts.serializer;\n    this.maxRetries = opts.maxRetries;\n    this.requestTimeout = toMs(opts.requestTimeout);\n    this.suggestCompression = opts.suggestCompression === true;\n    this.compression = opts.compression || false;\n    this.headers = Object.assign({}, {\n      'User-Agent': userAgent\n    }, opts.headers);\n    this.sniffInterval = opts.sniffInterval;\n    this.sniffOnConnectionFault = opts.sniffOnConnectionFault;\n    this.sniffEndpoint = opts.sniffEndpoint;\n    this.generateRequestId = opts.generateRequestId || generateRequestId();\n    this.name = opts.name;\n    this.nodeFilter = opts.nodeFilter || defaultNodeFilter;\n\n    if (typeof opts.nodeSelector === 'function') {\n      this.nodeSelector = opts.nodeSelector;\n    } else if (opts.nodeSelector === 'round-robin') {\n      this.nodeSelector = roundRobinSelector();\n    } else if (opts.nodeSelector === 'random') {\n      this.nodeSelector = randomSelector;\n    } else {\n      this.nodeSelector = roundRobinSelector();\n    }\n\n    this._sniffEnabled = typeof this.sniffInterval === 'number';\n    this._nextSniff = this._sniffEnabled ? Date.now() + this.sniffInterval : 0;\n    this._isSniffing = false;\n\n    if (opts.sniffOnStart === true) {\n      this.sniff({\n        reason: Transport.sniffReasons.SNIFF_ON_START\n      });\n    }\n  }\n\n  request(params, options, callback) {\n    options = options || {};\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } // promises support\n\n\n    if (callback == null) {\n      return new Promise((resolve, reject) => {\n        this.request(params, options, (err, result) => {\n          err ? reject(err) : resolve(result);\n        });\n      });\n    }\n\n    callback = once(callback);\n    const meta = {\n      context: options.context || null,\n      request: {\n        params: null,\n        options: null,\n        id: options.id || this.generateRequestId(params, options)\n      },\n      name: this.name,\n      connection: null,\n      attempts: 0,\n      aborted: false\n    };\n    const result = {\n      body: null,\n      statusCode: null,\n      headers: null,\n      warnings: options.warnings || null,\n      meta\n    };\n    const maxRetries = options.maxRetries || this.maxRetries;\n    const compression = options.compression || this.compression;\n    var request = {\n      abort: noop\n    };\n\n    const makeRequest = () => {\n      if (meta.aborted === true) return;\n      meta.connection = this.getConnection({\n        requestId: meta.request.id\n      });\n\n      if (meta.connection === null) {\n        return callback(new NoLivingConnectionsError('There are not living connections'), result);\n      } // TODO: make this assignment FAST\n\n\n      const headers = Object.assign({}, this.headers, options.headers); // handle json body\n\n      if (params.body != null) {\n        if (shouldSerialize(params.body) === true) {\n          try {\n            params.body = this.serializer.serialize(params.body);\n          } catch (err) {\n            return callback(err, result);\n          }\n        }\n\n        headers['Content-Type'] = headers['Content-Type'] || 'application/json';\n\n        if (compression === 'gzip') {\n          if (isStream(params.body) === false) {\n            params.body = intoStream(params.body).pipe(createGzip());\n          } else {\n            params.body = params.body.pipe(createGzip());\n          }\n\n          headers['Content-Encoding'] = compression;\n        }\n\n        if (isStream(params.body) === false) {\n          headers['Content-Length'] = '' + Buffer.byteLength(params.body);\n        } // handle ndjson body\n\n      } else if (params.bulkBody != null) {\n        if (shouldSerialize(params.bulkBody) === true) {\n          try {\n            params.body = this.serializer.ndserialize(params.bulkBody);\n          } catch (err) {\n            return callback(err, result);\n          }\n        } else {\n          params.body = params.bulkBody;\n        }\n\n        headers['Content-Type'] = headers['Content-Type'] || 'application/x-ndjson';\n\n        if (isStream(params.body) === false) {\n          headers['Content-Length'] = '' + Buffer.byteLength(params.body);\n        }\n      }\n\n      if (this.suggestCompression === true) {\n        headers['Accept-Encoding'] = 'gzip,deflate';\n      }\n\n      params.headers = headers; // serializes the querystring\n\n      if (options.querystring == null) {\n        params.querystring = this.serializer.qserialize(params.querystring);\n      } else {\n        params.querystring = this.serializer.qserialize(Object.assign({}, params.querystring, options.querystring));\n      }\n\n      meta.request.params = params;\n      meta.request.options = options;\n      this.emit('request', null, result); // handles request timeout\n\n      params.timeout = toMs(options.requestTimeout || this.requestTimeout);\n      if (options.asStream === true) params.asStream = true; // perform the actual http request\n\n      return meta.connection.request(params, onResponse);\n    };\n\n    const onResponse = (err, response) => {\n      if (err !== null) {\n        // if there is an error in the connection\n        // let's mark the connection as dead\n        this.connectionPool.markDead(meta.connection);\n\n        if (this.sniffOnConnectionFault === true) {\n          this.sniff({\n            reason: Transport.sniffReasons.SNIFF_ON_CONNECTION_FAULT,\n            requestId: meta.request.id\n          });\n        } // retry logic\n\n\n        if (meta.attempts < maxRetries) {\n          meta.attempts++;\n          debug(\"Retrying request, there are still \".concat(maxRetries - meta.attempts, \" attempts\"), params);\n          request = makeRequest(params, callback);\n          return;\n        }\n\n        const error = err instanceof TimeoutError ? err : new ConnectionError(err.message, result);\n\n        if (err.name === 'TimeoutError') {\n          err.meta = result;\n        }\n\n        this.emit('response', error, result);\n        return callback(error, result);\n      }\n\n      const statusCode = response.statusCode,\n            headers = response.headers;\n      result.statusCode = statusCode;\n      result.headers = headers;\n\n      if (headers['warning'] != null) {\n        result.warnings = result.warnings || []; // split the string over the commas not inside quotes\n\n        result.warnings.push.apply(result.warnings, headers['warning'].split(/(?!\\B\"[^\"]*),(?![^\"]*\"\\B)/));\n      }\n\n      if (options.asStream === true) {\n        result.body = response;\n        this.emit('response', null, result);\n        callback(null, result);\n        return;\n      }\n\n      var payload = ''; // collect the payload\n\n      response.setEncoding('utf8');\n      response.on('data', chunk => {\n        payload += chunk;\n      });\n      /* istanbul ignore next */\n\n      response.on('error', err => {\n        const error = new ConnectionError(err.message, result);\n        this.emit('response', error, result);\n        callback(error, result);\n      });\n      response.on('end', () => {\n        const isHead = params.method === 'HEAD'; // we should attempt the payload deserialization only if:\n        //    - a `content-type` is defined and is equal to `application/json`\n        //    - the request is not a HEAD request\n        //    - the payload is not an empty string\n\n        if (headers['content-type'] != null && headers['content-type'].indexOf('application/json') > -1 && isHead === false && payload !== '') {\n          try {\n            result.body = this.serializer.deserialize(payload);\n          } catch (err) {\n            this.emit('response', err, result);\n            return callback(err, result);\n          }\n        } else {\n          // cast to boolean if the request method was HEAD\n          result.body = isHead === true ? true : payload;\n        } // we should ignore the statusCode if the user has configured the `ignore` field with\n        // the statusCode we just got or if the request method is HEAD and the statusCode is 404\n\n\n        const ignoreStatusCode = Array.isArray(options.ignore) && options.ignore.indexOf(statusCode) > -1 || isHead === true && statusCode === 404;\n\n        if (ignoreStatusCode === false && (statusCode === 502 || statusCode === 503 || statusCode === 504)) {\n          // if the statusCode is 502/3/4 we should run our retry strategy\n          // and mark the connection as dead\n          this.connectionPool.markDead(meta.connection); // retry logic (we shoukd not retry on \"429 - Too Many Requests\")\n\n          if (meta.attempts < maxRetries && statusCode !== 429) {\n            meta.attempts++;\n            debug(\"Retrying request, there are still \".concat(maxRetries - meta.attempts, \" attempts\"), params);\n            request = makeRequest(params, callback);\n            return;\n          }\n        } else {\n          // everything has worked as expected, let's mark\n          // the connection as alive (or confirm it)\n          this.connectionPool.markAlive(meta.connection);\n        }\n\n        if (ignoreStatusCode === false && statusCode >= 400) {\n          const error = new ResponseError(result);\n          this.emit('response', error, result);\n          callback(error, result);\n        } else {\n          // cast to boolean if the request method was HEAD\n          if (isHead === true && statusCode === 404) {\n            result.body = false;\n          }\n\n          this.emit('response', null, result);\n          callback(null, result);\n        }\n      });\n    };\n\n    request = makeRequest();\n    return {\n      abort: () => {\n        meta.aborted = true;\n        request.abort();\n        debug('Aborting request', params);\n      }\n    };\n  }\n\n  getConnection(opts) {\n    const now = Date.now();\n\n    if (this._sniffEnabled === true && now > this._nextSniff) {\n      this.sniff({\n        reason: Transport.sniffReasons.SNIFF_INTERVAL,\n        requestId: opts.requestId\n      });\n    }\n\n    return this.connectionPool.getConnection({\n      filter: this.nodeFilter,\n      selector: this.nodeSelector,\n      requestId: opts.requestId,\n      name: this.name,\n      now\n    });\n  }\n\n  sniff(opts, callback = noop) {\n    if (this._isSniffing === true) return;\n    this._isSniffing = true;\n    debug('Started sniffing request');\n\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {\n        reason: Transport.sniffReasons.DEFAULT\n      };\n    }\n\n    const _opts = opts,\n          reason = _opts.reason;\n    const request = {\n      method: 'GET',\n      path: this.sniffEndpoint\n    };\n    this.request(request, {\n      id: opts.requestId\n    }, (err, result) => {\n      this._isSniffing = false;\n\n      if (this._sniffEnabled === true) {\n        this._nextSniff = Date.now() + this.sniffInterval;\n      }\n\n      if (err != null) {\n        debug('Sniffing errored', err);\n        result.meta.sniff = {\n          hosts: [],\n          reason\n        };\n        this.emit('sniff', err, result);\n        return callback(err);\n      }\n\n      debug('Sniffing ended successfully', result.body);\n      const protocol = result.meta.connection.url.protocol || 'http:';\n      const hosts = this.connectionPool.nodesToHost(result.body.nodes, protocol);\n      this.connectionPool.update(hosts);\n      result.meta.sniff = {\n        hosts,\n        reason\n      };\n      this.emit('sniff', null, result);\n      callback(null, hosts);\n    });\n  }\n\n}\n\nTransport.sniffReasons = {\n  SNIFF_ON_START: 'sniff-on-start',\n  SNIFF_INTERVAL: 'sniff-interval',\n  SNIFF_ON_CONNECTION_FAULT: 'sniff-on-connection-fault',\n  // TODO: find a better name\n  DEFAULT: 'default'\n};\n\nfunction toMs(time) {\n  if (typeof time === 'string') {\n    return ms(time);\n  }\n\n  return time;\n}\n\nfunction shouldSerialize(obj) {\n  return typeof obj !== 'string' && typeof obj.pipe !== 'function' && Buffer.isBuffer(obj) === false;\n}\n\nfunction isStream(obj) {\n  return typeof obj.pipe === 'function';\n}\n\nfunction defaultNodeFilter(node) {\n  // avoid master only nodes\n  if (node.roles.master === true && node.roles.data === false && node.roles.ingest === false) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction roundRobinSelector() {\n  var current = -1;\n  return function _roundRobinSelector(connections) {\n    if (++current >= connections.length) {\n      current = 0;\n    }\n\n    return connections[current];\n  };\n}\n\nfunction randomSelector(connections) {\n  const index = Math.floor(Math.random() * connections.length);\n  return connections[index];\n}\n\nfunction generateRequestId() {\n  var maxInt = 2147483647;\n  var nextReqId = 0;\n  return function genReqId(params, options) {\n    return nextReqId = nextReqId + 1 & maxInt;\n  };\n}\n\nmodule.exports = Transport;\nmodule.exports.internals = {\n  defaultNodeFilter,\n  roundRobinSelector,\n  randomSelector,\n  generateRequestId\n};","map":null,"metadata":{},"sourceType":"script"}