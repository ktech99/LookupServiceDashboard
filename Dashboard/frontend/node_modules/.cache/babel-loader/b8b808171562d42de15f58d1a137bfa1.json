{"ast":null,"code":"// Licensed to Elasticsearch B.V under one or more agreements.\n// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.\n// See the LICENSE file in the project root for more information\n'use strict';\n\nconst _require = require('url'),\n      URL = _require.URL;\n\nconst debug = require('debug')('elasticsearch');\n\nconst Connection = require('../Connection');\n\nconst noop = () => {};\n\nclass BaseConnectionPool {\n  constructor(opts) {\n    // list of nodes and weights\n    this.connections = []; // how many nodes we have in our scheduler\n\n    this.size = this.connections.length;\n    this.Connection = opts.Connection;\n    this.emit = opts.emit || noop;\n    this.auth = opts.auth || null;\n    this._ssl = opts.ssl;\n    this._agent = opts.agent;\n  }\n\n  getConnection() {\n    throw new Error('getConnection must be implemented');\n  }\n\n  markAlive() {\n    return this;\n  }\n\n  markDead() {\n    return this;\n  }\n  /**\n   * Creates a new connection instance.\n   */\n\n\n  createConnection(opts) {\n    if (typeof opts === 'string') {\n      opts = this.urlToHost(opts);\n    }\n\n    if (opts.url.username !== '' && opts.url.password !== '') {\n      opts.auth = {\n        username: decodeURIComponent(opts.url.username),\n        password: decodeURIComponent(opts.url.password)\n      };\n    } else if (this.auth !== null) {\n      opts.auth = this.auth;\n    }\n\n    if (opts.ssl == null) opts.ssl = this._ssl;\n    if (opts.agent == null) opts.agent = this._agent;\n    const connection = new this.Connection(opts);\n\n    for (const conn of this.connections) {\n      if (conn.id === connection.id) {\n        throw new Error(\"Connection with id '\".concat(connection.id, \"' is already present\"));\n      }\n    }\n\n    return connection;\n  }\n  /**\n   * Adds a new connection to the pool.\n   *\n   * @param {object|string} host\n   * @returns {ConnectionPool}\n   */\n\n\n  addConnection(opts) {\n    if (Array.isArray(opts)) {\n      return opts.forEach(o => this.addConnection(o));\n    }\n\n    if (typeof opts === 'string') {\n      opts = this.urlToHost(opts);\n    }\n\n    const connectionById = this.connections.find(c => c.id === opts.id);\n    const connectionByUrl = this.connections.find(c => c.id === opts.url.href);\n\n    if (connectionById || connectionByUrl) {\n      throw new Error(\"Connection with id '\".concat(opts.id || opts.url.href, \"' is already present\"));\n    }\n\n    this.update([...this.connections, opts]);\n    return this.connections[this.size - 1];\n  }\n  /**\n   * Removes a new connection to the pool.\n   *\n   * @param {object} connection\n   * @returns {ConnectionPool}\n   */\n\n\n  removeConnection(connection) {\n    debug('Removing connection', connection);\n    return this.update(this.connections.filter(c => c.id !== connection.id));\n  }\n  /**\n   * Empties the connection pool.\n   *\n   * @returns {ConnectionPool}\n   */\n\n\n  empty(callback) {\n    debug('Emptying the connection pool');\n    var openConnections = this.size;\n    this.connections.forEach(connection => {\n      connection.close(() => {\n        if (--openConnections === 0) {\n          this.connections = [];\n          this.size = this.connections.length;\n          callback();\n        }\n      });\n    });\n  }\n  /**\n   * Update the ConnectionPool with new connections.\n   *\n   * @param {array} array of connections\n   * @returns {ConnectionPool}\n   */\n\n\n  update(nodes) {\n    debug('Updating the connection pool');\n    const newConnections = [];\n    const oldConnections = [];\n\n    for (const node of nodes) {\n      // if we already have a given connection in the pool\n      // we mark it as alive and we do not close the connection\n      // to avoid socket issues\n      const connectionById = this.connections.find(c => c.id === node.id);\n      const connectionByUrl = this.connections.find(c => c.id === node.url.href);\n\n      if (connectionById) {\n        debug(\"The connection with id '\".concat(node.id, \"' is already present\"));\n        this.markAlive(connectionById);\n        newConnections.push(connectionById); // in case the user has passed a single url (or an array of urls),\n        // the connection id will be the full href; to avoid closing valid connections\n        // because are not present in the pool, we check also the node url,\n        // and if is already present we update its id with the ES provided one.\n      } else if (connectionByUrl) {\n        connectionByUrl.id = node.id;\n        this.markAlive(connectionByUrl);\n        newConnections.push(connectionByUrl);\n      } else {\n        newConnections.push(this.createConnection(node));\n      }\n    }\n\n    const ids = nodes.map(c => c.id); // remove all the dead connections and old connections\n\n    for (const connection of this.connections) {\n      if (ids.indexOf(connection.id) === -1) {\n        oldConnections.push(connection);\n      }\n    } // close old connections\n\n\n    oldConnections.forEach(connection => connection.close());\n    this.connections = newConnections;\n    this.size = this.connections.length;\n    return this;\n  }\n  /**\n   * Transforms the nodes objects to a host object.\n   *\n   * @param {object} nodes\n   * @returns {array} hosts\n   */\n\n\n  nodesToHost(nodes, protocol) {\n    const ids = Object.keys(nodes);\n    const hosts = [];\n\n    for (var i = 0, len = ids.length; i < len; i++) {\n      const node = nodes[ids[i]]; // If there is no protocol in\n      // the `publish_address` new URL will throw\n      // the publish_address can have two forms:\n      //   - ip:port\n      //   - hostname/ip:port\n      // if we encounter the second case, we should\n      // use the hostname instead of the ip\n\n      var address = node.http.publish_address;\n      const parts = address.split('/'); // the url is in the form of hostname/ip:port\n\n      if (parts.length > 1) {\n        const hostname = parts[0];\n        const port = parts[1].match(/((?::))(?:[0-9]+)$/g)[0].slice(1);\n        address = \"\".concat(hostname, \":\").concat(port);\n      }\n\n      address = address.slice(0, 4) === 'http' ? address : \"\".concat(protocol, \"//\").concat(address);\n      const roles = node.roles.reduce((acc, role) => {\n        acc[role] = true;\n        return acc;\n      }, {});\n      hosts.push({\n        url: new URL(address),\n        id: ids[i],\n        roles: Object.assign({\n          [Connection.roles.MASTER]: true,\n          [Connection.roles.DATA]: true,\n          [Connection.roles.INGEST]: true,\n          [Connection.roles.ML]: false\n        }, roles)\n      });\n    }\n\n    return hosts;\n  }\n  /**\n   * Transforms an url string to a host object\n   *\n   * @param {string} url\n   * @returns {object} host\n   */\n\n\n  urlToHost(url) {\n    return {\n      url: new URL(url)\n    };\n  }\n\n}\n\nmodule.exports = BaseConnectionPool;","map":null,"metadata":{},"sourceType":"script"}