{"ast":null,"code":"// Licensed to Elasticsearch B.V under one or more agreements.\n// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.\n// See the LICENSE file in the project root for more information\n'use strict';\n\nvar _objectWithoutProperties = require(\"/Users/kartik/Desktop/ls_dashboard/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nconst assert = require('assert');\n\nconst _require = require('util'),\n      inspect = _require.inspect;\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst debug = require('debug')('elasticsearch');\n\nconst decompressResponse = require('decompress-response');\n\nconst pump = require('pump');\n\nconst INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\n\nconst _require2 = require('./errors'),\n      TimeoutError = _require2.TimeoutError,\n      ConfigurationError = _require2.ConfigurationError;\n\nclass Connection {\n  constructor(opts = {}) {\n    this.url = opts.url;\n    this.ssl = opts.ssl || null;\n    this.id = opts.id || stripAuth(opts.url.href);\n    this.headers = prepareHeaders(opts.headers, opts.auth);\n    this.deadCount = 0;\n    this.resurrectTimeout = 0;\n    this._openRequests = 0;\n    this._status = opts.status || Connection.statuses.ALIVE;\n    this.roles = Object.assign({}, defaultRoles, opts.roles);\n\n    if (!['http:', 'https:'].includes(this.url.protocol)) {\n      throw new ConfigurationError(\"Invalid protocol: '\".concat(this.url.protocol, \"'\"));\n    }\n\n    if (typeof opts.agent === 'function') {\n      this.agent = opts.agent();\n    } else {\n      const keepAliveFalse = opts.agent && opts.agent.keepAlive === false;\n      const agentOptions = Object.assign({}, {\n        keepAlive: true,\n        keepAliveMsecs: 1000,\n        maxSockets: keepAliveFalse ? Infinity : 256,\n        maxFreeSockets: 256\n      }, opts.agent);\n      this.agent = this.url.protocol === 'http:' ? new http.Agent(agentOptions) : new https.Agent(Object.assign({}, agentOptions, this.ssl));\n    }\n\n    this.makeRequest = this.url.protocol === 'http:' ? http.request : https.request;\n  }\n\n  request(params, callback) {\n    this._openRequests++;\n    var ended = false;\n    const requestParams = this.buildRequestObject(params); // https://github.com/nodejs/node/commit/b961d9fd83\n\n    if (INVALID_PATH_REGEX.test(requestParams.path) === true) {\n      callback(new TypeError(\"ERR_UNESCAPED_CHARACTERS: \".concat(requestParams.path)), null);\n      return {\n        abort: () => {}\n      };\n    }\n\n    debug('Starting a new request', params);\n    const request = this.makeRequest(requestParams); // listen for the response event\n    // TODO: handle redirects?\n\n    request.on('response', response => {\n      if (ended === false) {\n        ended = true;\n        this._openRequests--;\n\n        if (params.asStream === true) {\n          callback(null, response);\n        } else {\n          callback(null, decompressResponse(response));\n        }\n      }\n    }); // handles request timeout\n\n    request.on('timeout', () => {\n      if (ended === false) {\n        ended = true;\n        this._openRequests--;\n        request.abort();\n        callback(new TimeoutError('Request timed out', params), null);\n      }\n    }); // handles request error\n\n    request.on('error', err => {\n      if (ended === false) {\n        ended = true;\n        this._openRequests--;\n        callback(err, null);\n      }\n    }); // updates the ended state\n\n    request.on('abort', () => {\n      debug('Request aborted', params);\n\n      if (ended === false) {\n        ended = true;\n        this._openRequests--;\n      }\n    }); // Disables the Nagle algorithm\n\n    request.setNoDelay(true); // starts the request\n\n    if (isStream(params.body) === true) {\n      pump(params.body, request, err => {\n        /* istanbul ignore if  */\n        if (err != null && ended === false) {\n          ended = true;\n          this._openRequests--;\n          callback(err, null);\n        }\n      });\n    } else {\n      request.end(params.body);\n    }\n\n    return request;\n  } // TODO: write a better closing logic\n\n\n  close(callback = () => {}) {\n    debug('Closing connection', this.id);\n\n    if (this._openRequests > 0) {\n      setTimeout(() => this.close(callback), 1000);\n    } else {\n      this.agent.destroy();\n      callback();\n    }\n  }\n\n  setRole(role, enabled) {\n    if (validRoles.indexOf(role) === -1) {\n      throw new ConfigurationError(\"Unsupported role: '\".concat(role, \"'\"));\n    }\n\n    if (typeof enabled !== 'boolean') {\n      throw new ConfigurationError('enabled should be a boolean');\n    }\n\n    this.roles[role] = enabled;\n    return this;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  set status(status) {\n    assert(~validStatuses.indexOf(status), \"Unsupported status: '\".concat(status, \"'\"));\n    this._status = status;\n  }\n\n  buildRequestObject(params) {\n    const url = this.url;\n    const request = {\n      protocol: url.protocol,\n      hostname: url.hostname[0] === '[' ? url.hostname.slice(1, -1) : url.hostname,\n      hash: url.hash,\n      search: url.search,\n      pathname: url.pathname,\n      path: '',\n      href: url.href,\n      origin: url.origin,\n      // https://github.com/elastic/elasticsearch-js/issues/843\n      port: url.port !== '' ? url.port : undefined,\n      headers: this.headers,\n      agent: this.agent\n    };\n    const paramsKeys = Object.keys(params);\n\n    for (var i = 0, len = paramsKeys.length; i < len; i++) {\n      var key = paramsKeys[i];\n\n      if (key === 'path') {\n        request.pathname = resolve(request.pathname, params[key]);\n      } else if (key === 'querystring' && !!params[key] === true) {\n        if (request.search === '') {\n          request.search = '?' + params[key];\n        } else {\n          request.search += '&' + params[key];\n        }\n      } else if (key === 'headers') {\n        request.headers = Object.assign({}, request.headers, params.headers);\n      } else {\n        request[key] = params[key];\n      }\n    }\n\n    request.path = request.pathname + request.search;\n    return request;\n  } // Handles console.log and utils.inspect invocations.\n  // We want to hide `auth`, `agent` and `ssl` since they made\n  // the logs very hard to read. The user can still\n  // access them with `instance.agent` and `instance.ssl`.\n\n\n  [inspect.custom](depth, options) {\n    const _this$headers = this.headers,\n          authorization = _this$headers.authorization,\n          headers = _objectWithoutProperties(_this$headers, [\"authorization\"]);\n\n    return {\n      url: stripAuth(this.url.toString()),\n      id: this.id,\n      headers,\n      deadCount: this.deadCount,\n      resurrectTimeout: this.resurrectTimeout,\n      _openRequests: this._openRequests,\n      status: this.status,\n      roles: this.roles\n    };\n  }\n\n  toJSON() {\n    const _this$headers2 = this.headers,\n          authorization = _this$headers2.authorization,\n          headers = _objectWithoutProperties(_this$headers2, [\"authorization\"]);\n\n    return {\n      url: stripAuth(this.url.toString()),\n      id: this.id,\n      headers,\n      deadCount: this.deadCount,\n      resurrectTimeout: this.resurrectTimeout,\n      _openRequests: this._openRequests,\n      status: this.status,\n      roles: this.roles\n    };\n  }\n\n}\n\nConnection.statuses = {\n  ALIVE: 'alive',\n  DEAD: 'dead'\n};\nConnection.roles = {\n  MASTER: 'master',\n  DATA: 'data',\n  INGEST: 'ingest',\n  ML: 'ml'\n};\nconst defaultRoles = {\n  [Connection.roles.MASTER]: true,\n  [Connection.roles.DATA]: true,\n  [Connection.roles.INGEST]: true,\n  [Connection.roles.ML]: false\n};\nconst validStatuses = Object.keys(Connection.statuses).map(k => Connection.statuses[k]);\nconst validRoles = Object.keys(Connection.roles).map(k => Connection.roles[k]);\n\nfunction stripAuth(url) {\n  if (url.indexOf('@') === -1) return url;\n  return url.slice(0, url.indexOf('//') + 2) + url.slice(url.indexOf('@') + 1);\n}\n\nfunction isStream(obj) {\n  return obj != null && typeof obj.pipe === 'function';\n}\n\nfunction resolve(host, path) {\n  const hostEndWithSlash = host[host.length - 1] === '/';\n  const pathStartsWithSlash = path[0] === '/';\n\n  if (hostEndWithSlash === true && pathStartsWithSlash === true) {\n    return host + path.slice(1);\n  } else if (hostEndWithSlash !== pathStartsWithSlash) {\n    return host + path;\n  } else {\n    return host + '/' + path;\n  }\n}\n\nfunction prepareHeaders(headers = {}, auth) {\n  if (auth != null && headers.authorization == null) {\n    if (auth.username && auth.password) {\n      headers.authorization = 'Basic ' + Buffer.from(\"\".concat(auth.username, \":\").concat(auth.password)).toString('base64');\n    }\n\n    if (auth.apiKey) {\n      if (typeof auth.apiKey === 'object') {\n        headers.authorization = 'ApiKey ' + Buffer.from(\"\".concat(auth.apiKey.id, \":\").concat(auth.apiKey.api_key)).toString('base64');\n      } else {\n        headers.authorization = \"ApiKey \".concat(auth.apiKey);\n      }\n    }\n  }\n\n  return headers;\n}\n\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}