{"ast":null,"code":"// Licensed to Elasticsearch B.V under one or more agreements.\n// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.\n// See the LICENSE file in the project root for more information\n'use strict';\n\nconst BaseConnectionPool = require('./BaseConnectionPool');\n\nconst assert = require('assert');\n\nconst debug = require('debug')('elasticsearch');\n\nconst Connection = require('../Connection');\n\nconst noop = () => {};\n\nclass ConnectionPool extends BaseConnectionPool {\n  constructor(opts = {}) {\n    super(opts);\n    this.dead = []; // the resurrect timeout is 60s\n\n    this.resurrectTimeout = 1000 * 60; // number of consecutive failures after which\n    // the timeout doesn't increase\n\n    this.resurrectTimeoutCutoff = 5;\n    this.pingTimeout = opts.pingTimeout;\n    this._sniffEnabled = opts.sniffEnabled || false;\n    const resurrectStrategy = opts.resurrectStrategy || 'ping';\n    this.resurrectStrategy = ConnectionPool.resurrectStrategies[resurrectStrategy];\n    assert(this.resurrectStrategy != null, \"Invalid resurrection strategy: '\".concat(resurrectStrategy, \"'\"));\n  }\n  /**\n   * Marks a connection as 'alive'.\n   * If needed removes the connection from the dead list\n   * and then resets the `deadCount`.\n   * If sniffing is not enabled and there is only\n   * one node, this method is a noop.\n   *\n   * @param {object} connection\n   */\n\n\n  markAlive(connection) {\n    if (this._sniffEnabled === false && this.size === 1) return this;\n    const id = connection.id;\n    debug(\"Marking as 'alive' connection '\".concat(id, \"'\"));\n    const index = this.dead.indexOf(id);\n    if (index > -1) this.dead.splice(index, 1);\n    connection.status = Connection.statuses.ALIVE;\n    connection.deadCount = 0;\n    connection.resurrectTimeout = 0;\n    return this;\n  }\n  /**\n   * Marks a connection as 'dead'.\n   * If needed adds the connection to the dead list\n   * and then increments the `deadCount`.\n   * If sniffing is not enabled and there is only\n   * one node, this method is a noop.\n   *\n   * @param {object} connection\n   */\n\n\n  markDead(connection) {\n    if (this._sniffEnabled === false && this.size === 1) return this;\n    const id = connection.id;\n    debug(\"Marking as 'dead' connection '\".concat(id, \"'\"));\n\n    if (this.dead.indexOf(id) === -1) {\n      this.dead.push(id);\n    }\n\n    connection.status = Connection.statuses.DEAD;\n    connection.deadCount++; // resurrectTimeout formula:\n    // `resurrectTimeout * 2 ** min(deadCount - 1, resurrectTimeoutCutoff)`\n\n    connection.resurrectTimeout = Date.now() + this.resurrectTimeout * Math.pow(2, Math.min(connection.deadCount - 1, this.resurrectTimeoutCutoff)); // sort the dead list in ascending order\n    // based on the resurrectTimeout\n\n    this.dead.sort((a, b) => {\n      const conn1 = this.connections.find(c => c.id === a);\n      const conn2 = this.connections.find(c => c.id === b);\n      return conn1.resurrectTimeout - conn2.resurrectTimeout;\n    });\n    return this;\n  }\n  /**\n   * If enabled, tries to resurrect a connection with the given\n   * resurrect strategy ('ping', 'optimistic', 'none').\n   *\n   * @param {object} { now, requestId }\n   * @param {function} callback (isAlive, connection)\n   */\n\n\n  resurrect(opts, callback = noop) {\n    if (this.resurrectStrategy === 0 || this.dead.length === 0) {\n      debug('Nothing to resurrect');\n      callback(null, null);\n      return;\n    } // the dead list is sorted in ascending order based on the timeout\n    // so the first element will always be the one with the smaller timeout\n\n\n    const connection = this.connections.find(c => c.id === this.dead[0]);\n\n    if ((opts.now || Date.now()) < connection.resurrectTimeout) {\n      debug('Nothing to resurrect');\n      callback(null, null);\n      return;\n    }\n\n    const id = connection.id; // ping strategy\n\n    if (this.resurrectStrategy === 1) {\n      connection.request({\n        method: 'HEAD',\n        path: '/',\n        timeout: this.pingTimeout\n      }, (err, response) => {\n        var isAlive = true;\n        const statusCode = response !== null ? response.statusCode : 0;\n\n        if (err != null || statusCode === 502 || statusCode === 503 || statusCode === 504) {\n          debug(\"Resurrect: connection '\".concat(id, \"' is still dead\"));\n          this.markDead(connection);\n          isAlive = false;\n        } else {\n          debug(\"Resurrect: connection '\".concat(id, \"' is now alive\"));\n          this.markAlive(connection);\n        }\n\n        this.emit('resurrect', null, {\n          strategy: 'ping',\n          name: opts.name,\n          request: {\n            id: opts.requestId\n          },\n          isAlive,\n          connection\n        });\n        callback(isAlive, connection);\n      }); // optimistic strategy\n    } else {\n      debug(\"Resurrect: optimistic resurrection for connection '\".concat(id, \"'\"));\n      this.dead.splice(this.dead.indexOf(id), 1);\n      connection.status = Connection.statuses.ALIVE;\n      this.emit('resurrect', null, {\n        strategy: 'optimistic',\n        name: opts.name,\n        request: {\n          id: opts.requestId\n        },\n        isAlive: true,\n        connection\n      }); // eslint-disable-next-line standard/no-callback-literal\n\n      callback(true, connection);\n    }\n  }\n  /**\n   * Returns an alive connection if present,\n   * otherwise returns null.\n   * By default it filters the `master` only nodes.\n   * It uses the selector to choose which\n   * connection return.\n   *\n   * @param {object} options (filter and selector)\n   * @returns {object|null} connection\n   */\n\n\n  getConnection(opts = {}) {\n    const filter = opts.filter || (() => true);\n\n    const selector = opts.selector || (c => c[0]);\n\n    this.resurrect({\n      now: opts.now,\n      requestId: opts.requestId,\n      name: opts.name\n    }); // TODO: can we cache this?\n\n    const connections = [];\n\n    for (var i = 0; i < this.size; i++) {\n      const connection = this.connections[i];\n\n      if (connection.status === Connection.statuses.ALIVE) {\n        if (filter(connection) === true) {\n          connections.push(connection);\n        }\n      }\n    }\n\n    if (connections.length === 0) return null;\n    return selector(connections);\n  }\n  /**\n   * Empties the connection pool.\n   *\n   * @returns {ConnectionPool}\n   */\n\n\n  empty(callback) {\n    super.empty(() => {\n      this.dead = [];\n      callback();\n    });\n  }\n  /**\n   * Update the ConnectionPool with new connections.\n   *\n   * @param {array} array of connections\n   * @returns {ConnectionPool}\n   */\n\n\n  update(connections) {\n    super.update(connections);\n\n    for (var i = 0; i < this.dead.length; i++) {\n      if (this.connections.find(c => c.id === this.dead[i]) === undefined) {\n        this.dead.splice(i, 1);\n      }\n    }\n\n    return this;\n  }\n\n}\n\nConnectionPool.resurrectStrategies = {\n  none: 0,\n  ping: 1,\n  optimistic: 2\n};\nmodule.exports = ConnectionPool;","map":null,"metadata":{},"sourceType":"script"}