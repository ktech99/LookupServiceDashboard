{"ast":null,"code":"// Licensed to Elasticsearch B.V under one or more agreements.\n// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.\n// See the LICENSE file in the project root for more information\n'use strict';\n\nvar _slicedToArray = require(\"/Users/kartik/Desktop/ls_dashboard/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst _require = require('events'),\n      EventEmitter = _require.EventEmitter;\n\nconst _require2 = require('url'),\n      URL = _require2.URL;\n\nconst debug = require('debug')('elasticsearch');\n\nconst Transport = require('./lib/Transport');\n\nconst Connection = require('./lib/Connection');\n\nconst _require3 = require('./lib/pool'),\n      ConnectionPool = _require3.ConnectionPool,\n      CloudConnectionPool = _require3.CloudConnectionPool;\n\nconst Serializer = require('./lib/Serializer');\n\nconst errors = require('./lib/errors');\n\nconst ConfigurationError = errors.ConfigurationError;\nconst kInitialOptions = Symbol('elasticsearchjs-initial-options');\nconst kChild = Symbol('elasticsearchjs-child');\nconst kExtensions = Symbol('elasticsearchjs-extensions');\n\nconst buildApi = require('./api');\n\nclass Client extends EventEmitter {\n  constructor(opts = {}) {\n    super();\n\n    if (opts.cloud) {\n      const _opts$cloud = opts.cloud,\n            id = _opts$cloud.id,\n            username = _opts$cloud.username,\n            password = _opts$cloud.password; // the cloud id is `cluster-name:base64encodedurl`\n      // the url is a string divided by two '$', the first is the cloud url\n      // the second the elasticsearch instance, the third the kibana instance\n\n      const cloudUrls = Buffer.from(id.split(':')[1], 'base64').toString().split('$'); // TODO: remove username and password here in 8\n\n      if (username && password) {\n        opts.auth = Object.assign({}, opts.auth, {\n          username,\n          password\n        });\n      }\n\n      opts.node = \"https://\".concat(cloudUrls[1], \".\").concat(cloudUrls[0]); // Cloud has better performances with compression enabled\n      // see https://github.com/elastic/elasticsearch-py/pull/704.\n      // So unless the user specifies otherwise, we enable compression.\n\n      if (opts.compression == null) opts.compression = 'gzip';\n      if (opts.suggestCompression == null) opts.suggestCompression = true;\n\n      if (opts.ssl == null || opts.ssl && opts.ssl.secureProtocol == null) {\n        opts.ssl = opts.ssl || {};\n        opts.ssl.secureProtocol = 'TLSv1_2_method';\n      }\n    }\n\n    if (!opts.node && !opts.nodes) {\n      throw new ConfigurationError('Missing node(s) option');\n    }\n\n    const checkAuth = getAuth(opts.node || opts.nodes);\n\n    if (checkAuth && checkAuth.username && checkAuth.password) {\n      opts.auth = Object.assign({}, opts.auth, {\n        username: checkAuth.username,\n        password: checkAuth.password\n      });\n    }\n\n    const options = Object.assign({}, {\n      Connection,\n      Transport,\n      Serializer,\n      ConnectionPool: opts.cloud ? CloudConnectionPool : ConnectionPool,\n      maxRetries: 3,\n      requestTimeout: 30000,\n      pingTimeout: 3000,\n      sniffInterval: false,\n      sniffOnStart: false,\n      sniffEndpoint: '_nodes/_all/http',\n      sniffOnConnectionFault: false,\n      resurrectStrategy: 'ping',\n      suggestCompression: false,\n      compression: false,\n      ssl: null,\n      agent: null,\n      headers: {},\n      nodeFilter: null,\n      nodeSelector: 'round-robin',\n      generateRequestId: null,\n      name: 'elasticsearch-js',\n      auth: null\n    }, opts);\n    this[kInitialOptions] = options;\n    this[kExtensions] = [];\n    this.name = options.name;\n    this.serializer = new options.Serializer();\n    this.connectionPool = new options.ConnectionPool({\n      pingTimeout: options.pingTimeout,\n      resurrectStrategy: options.resurrectStrategy,\n      ssl: options.ssl,\n      agent: options.agent,\n      Connection: options.Connection,\n      auth: options.auth,\n      emit: this.emit.bind(this),\n      sniffEnabled: options.sniffInterval !== false || options.sniffOnStart !== false || options.sniffOnConnectionFault !== false\n    }); // Add the connections before initialize the Transport\n\n    if (opts[kChild] !== true) {\n      this.connectionPool.addConnection(options.node || options.nodes);\n    }\n\n    this.transport = new options.Transport({\n      emit: this.emit.bind(this),\n      connectionPool: this.connectionPool,\n      serializer: this.serializer,\n      maxRetries: options.maxRetries,\n      requestTimeout: options.requestTimeout,\n      sniffInterval: options.sniffInterval,\n      sniffOnStart: options.sniffOnStart,\n      sniffOnConnectionFault: options.sniffOnConnectionFault,\n      sniffEndpoint: options.sniffEndpoint,\n      suggestCompression: options.suggestCompression,\n      compression: options.compression,\n      headers: options.headers,\n      nodeFilter: options.nodeFilter,\n      nodeSelector: options.nodeSelector,\n      generateRequestId: options.generateRequestId,\n      name: options.name\n    });\n    const apis = buildApi({\n      makeRequest: this.transport.request.bind(this.transport),\n      result: {\n        body: null,\n        statusCode: null,\n        headers: null,\n        warnings: null\n      },\n      ConfigurationError\n    });\n    Object.keys(apis).forEach(api => {\n      this[api] = apis[api];\n    });\n  }\n\n  extend(name, opts, fn) {\n    if (typeof opts === 'function') {\n      fn = opts;\n      opts = {};\n    }\n\n    var _name$split = name.split('.'),\n        _name$split2 = _slicedToArray(_name$split, 2),\n        namespace = _name$split2[0],\n        method = _name$split2[1];\n\n    if (method == null) {\n      method = namespace;\n      namespace = null;\n    }\n\n    if (namespace != null) {\n      if (this[namespace] != null && this[namespace][method] != null && opts.force !== true) {\n        throw new Error(\"The method \\\"\".concat(method, \"\\\" already exists on namespace \\\"\").concat(namespace, \"\\\"\"));\n      }\n\n      this[namespace] = this[namespace] || {};\n      this[namespace][method] = fn({\n        makeRequest: this.transport.request.bind(this.transport),\n        result: {\n          body: null,\n          statusCode: null,\n          headers: null,\n          warnings: null\n        },\n        ConfigurationError\n      });\n    } else {\n      if (this[method] != null && opts.force !== true) {\n        throw new Error(\"The method \\\"\".concat(method, \"\\\" already exists\"));\n      }\n\n      this[method] = fn({\n        makeRequest: this.transport.request.bind(this.transport),\n        result: {\n          body: null,\n          statusCode: null,\n          headers: null,\n          warnings: null\n        },\n        ConfigurationError\n      });\n    }\n\n    this[kExtensions].push({\n      name,\n      opts,\n      fn\n    });\n  }\n\n  child(opts) {\n    // Merge the new options with the initial ones\n    const initialOptions = Object.assign({}, this[kInitialOptions], opts); // Tell to the client that we are creating a child client\n\n    initialOptions[kChild] = true;\n    const client = new Client(initialOptions); // Reuse the same connection pool\n\n    client.connectionPool = this.connectionPool;\n    client.transport.connectionPool = this.connectionPool; // Share event listener\n\n    const emitter = this.emit.bind(this);\n    client.emit = emitter;\n    client.connectionPool.emit = emitter;\n    client.transport.emit = emitter;\n    client.on = this.on.bind(this); // Add parent extensions\n\n    this[kExtensions].forEach(({\n      name,\n      opts,\n      fn\n    }) => {\n      client.extend(name, opts, fn);\n    });\n    return client;\n  }\n\n  close(callback) {\n    if (callback == null) {\n      return new Promise((resolve, reject) => {\n        this.close(resolve);\n      });\n    }\n\n    debug('Closing the client');\n    this.connectionPool.empty(callback);\n  }\n\n}\n\nfunction getAuth(node) {\n  if (Array.isArray(node)) {\n    for (const url of node) {\n      const auth = getUsernameAndPassword(url);\n\n      if (auth.username !== '' && auth.password !== '') {\n        return auth;\n      }\n    }\n\n    return null;\n  }\n\n  const auth = getUsernameAndPassword(node);\n\n  if (auth.username !== '' && auth.password !== '') {\n    return auth;\n  }\n\n  return null;\n\n  function getUsernameAndPassword(node) {\n    if (typeof node === 'string') {\n      const _ref = new URL(node),\n            username = _ref.username,\n            password = _ref.password;\n\n      return {\n        username: decodeURIComponent(username),\n        password: decodeURIComponent(password)\n      };\n    } else if (node.url instanceof URL) {\n      return {\n        username: decodeURIComponent(node.url.username),\n        password: decodeURIComponent(node.url.password)\n      };\n    }\n  }\n}\n\nconst events = {\n  RESPONSE: 'response',\n  REQUEST: 'request',\n  SNIFF: 'sniff',\n  RESURRECT: 'resurrect'\n};\nmodule.exports = {\n  Client,\n  Transport,\n  ConnectionPool,\n  Connection,\n  Serializer,\n  events,\n  errors\n};","map":null,"metadata":{},"sourceType":"script"}